"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  ClerkWebAuthnError: () => import_error.ClerkWebAuthnError,
  arrayBufferToBase64Url: () => arrayBufferToBase64Url,
  base64urlToArrayBuffer: () => base64urlToArrayBuffer,
  decodeBase64: () => decodeBase64,
  decodeBase64Url: () => decodeBase64Url,
  decodeToken: () => decodeToken,
  encodeBase64: () => encodeBase64,
  encodeBase64Url: () => encodeBase64Url,
  mapNativeErrorToClerkWebAuthnErrorCode: () => mapNativeErrorToClerkWebAuthnErrorCode,
  toArrayBuffer: () => toArrayBuffer,
  utf8Decode: () => utf8Decode
});
module.exports = __toCommonJS(utils_exports);
var import_node_buffer = require("node:buffer");
var import_error = require("@clerk/shared/error");
function encodeBase64(data) {
  return btoa(String.fromCharCode(...new Uint8Array(data)));
}
function encodeBase64Url(data) {
  return encodeBase64(data).replaceAll("=", "").replaceAll("+", "-").replaceAll("/", "_");
}
function decodeBase64Url(data) {
  return decodeBase64(data.replaceAll("-", "+").replaceAll("_", "/"));
}
function decodeToken(data) {
  const base64 = data.replace(/-/g, "+").replace(/_/g, "/");
  const jsonPayload = decodeURIComponent(
    atob(base64).split("").map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)).join("")
  );
  return JSON.parse(jsonPayload);
}
function decodeBase64(data) {
  return Uint8Array.from(atob(data).split(""), (x) => x.charCodeAt(0));
}
function utf8Decode(buffer) {
  const textDecoder = new TextDecoder();
  return textDecoder.decode(buffer);
}
function toArrayBuffer(bufferSource) {
  if (bufferSource instanceof ArrayBuffer) {
    return bufferSource;
  } else if (ArrayBuffer.isView(bufferSource)) {
    return bufferSource.buffer;
  } else {
    throw new TypeError("Expected a BufferSource, but received an incompatible type.");
  }
}
function base64urlToArrayBuffer(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const binaryString = import_node_buffer.Buffer.from(base64, "base64").toString("binary");
  const len = binaryString.length;
  const buffer = new ArrayBuffer(len);
  const uintArray = new Uint8Array(buffer);
  for (let i = 0; i < len; i++) {
    uintArray[i] = binaryString.charCodeAt(i);
  }
  return buffer;
}
function arrayBufferToBase64Url(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  const base64String = btoa(binary);
  const base64Url = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  return base64Url;
}
function mapNativeErrorToClerkWebAuthnErrorCode(code, message, action) {
  if (code === "1000" || code === "1004" || code === "CreatePublicKeyCredentialDomException") {
    return new import_error.ClerkWebAuthnError(message, {
      code: action === "create" ? "passkey_registration_failed" : "passkey_retrieval_failed"
    });
  }
  if (code === "1001" || code === "CreateCredentialCancellationException" || code === "GetCredentialCancellationException") {
    return new import_error.ClerkWebAuthnError(message, { code: "passkey_registration_cancelled" });
  }
  if (code === "1002") {
    return new import_error.ClerkWebAuthnError(message, { code: "passkey_invalid_rpID_or_domain" });
  }
  if (code === "1003" || code === "CreateCredentialInterruptedException") {
    return new import_error.ClerkWebAuthnError(message, { code: "passkey_operation_aborted" });
  }
  return new import_error.ClerkWebAuthnError(message, {
    code: action === "create" ? "passkey_registration_failed" : "passkey_retrieval_failed"
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClerkWebAuthnError,
  arrayBufferToBase64Url,
  base64urlToArrayBuffer,
  decodeBase64,
  decodeBase64Url,
  decodeToken,
  encodeBase64,
  encodeBase64Url,
  mapNativeErrorToClerkWebAuthnErrorCode,
  toArrayBuffer,
  utf8Decode
});
//# sourceMappingURL=utils.js.map