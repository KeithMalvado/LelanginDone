"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  create: () => create,
  get: () => get,
  isSupported: () => isSupported,
  passkeys: () => passkeys
});
module.exports = __toCommonJS(src_exports);
var import_react_native = require("react-native");
var import_ClerkExpoPasskeysModule = __toESM(require("./ClerkExpoPasskeysModule"));
var import_utils = require("./utils");
const makeSerializedCreateResponse = (publicCredential) => ({
  id: publicCredential.id,
  rawId: (0, import_utils.base64urlToArrayBuffer)(publicCredential.rawId),
  response: {
    getTransports: () => {
      var _a;
      return (_a = publicCredential == null ? void 0 : publicCredential.response) == null ? void 0 : _a.transports;
    },
    attestationObject: (0, import_utils.base64urlToArrayBuffer)(publicCredential.response.attestationObject),
    clientDataJSON: (0, import_utils.base64urlToArrayBuffer)(publicCredential.response.clientDataJSON)
  },
  type: publicCredential.type,
  authenticatorAttachment: publicCredential.authenticatorAttachment || null,
  toJSON: () => publicCredential
});
async function create(publicKey) {
  if (!publicKey || !publicKey.rp.id) {
    throw new Error("Invalid public key or RpID");
  }
  const createOptions = {
    rp: { id: publicKey.rp.id, name: publicKey.rp.name },
    user: {
      id: (0, import_utils.encodeBase64Url)((0, import_utils.toArrayBuffer)(publicKey.user.id)),
      displayName: publicKey.user.displayName,
      name: publicKey.user.name
    },
    pubKeyCredParams: publicKey.pubKeyCredParams,
    challenge: (0, import_utils.encodeBase64Url)((0, import_utils.toArrayBuffer)(publicKey.challenge)),
    authenticatorSelection: {
      authenticatorAttachment: "platform",
      requireResidentKey: true,
      residentKey: "required",
      userVerification: "required"
    },
    excludeCredentials: publicKey.excludeCredentials.map((c) => ({
      type: "public-key",
      id: (0, import_utils.encodeBase64Url)((0, import_utils.toArrayBuffer)(c.id))
    }))
  };
  const createPasskeyModule = import_react_native.Platform.select({
    android: async () => import_ClerkExpoPasskeysModule.default.create(JSON.stringify(createOptions)),
    ios: async () => import_ClerkExpoPasskeysModule.default.create(
      createOptions.challenge,
      createOptions.rp.id,
      createOptions.user.id,
      createOptions.user.displayName
    ),
    default: null
  });
  if (!createPasskeyModule) {
    throw new Error("Platform not supported");
  }
  try {
    const response = await createPasskeyModule();
    return {
      publicKeyCredential: makeSerializedCreateResponse(typeof response === "string" ? JSON.parse(response) : response),
      error: null
    };
  } catch (error) {
    return {
      publicKeyCredential: null,
      error: (0, import_utils.mapNativeErrorToClerkWebAuthnErrorCode)(error.code, error.message, "create")
    };
  }
}
const makeSerializedGetResponse = (publicKeyCredential) => {
  return {
    type: publicKeyCredential.type,
    id: publicKeyCredential.id,
    rawId: (0, import_utils.base64urlToArrayBuffer)(publicKeyCredential.rawId),
    authenticatorAttachment: (publicKeyCredential == null ? void 0 : publicKeyCredential.authenticatorAttachment) || null,
    response: {
      clientDataJSON: (0, import_utils.base64urlToArrayBuffer)(publicKeyCredential.response.clientDataJSON),
      authenticatorData: (0, import_utils.base64urlToArrayBuffer)(publicKeyCredential.response.authenticatorData),
      signature: (0, import_utils.base64urlToArrayBuffer)(publicKeyCredential.response.signature),
      userHandle: (publicKeyCredential == null ? void 0 : publicKeyCredential.response.userHandle) ? (0, import_utils.base64urlToArrayBuffer)(publicKeyCredential == null ? void 0 : publicKeyCredential.response.userHandle) : null
    },
    toJSON: () => publicKeyCredential
  };
};
async function get({
  publicKeyOptions
}) {
  if (!publicKeyOptions) {
    throw new Error("publicKeyCredential has not been provided");
  }
  const serializedPublicCredential = {
    ...publicKeyOptions,
    // @ts-expect-error FIXME
    challenge: (0, import_utils.arrayBufferToBase64Url)(publicKeyOptions.challenge)
  };
  const getPasskeyModule = import_react_native.Platform.select({
    android: async () => import_ClerkExpoPasskeysModule.default.get(JSON.stringify(serializedPublicCredential)),
    ios: async () => import_ClerkExpoPasskeysModule.default.get(serializedPublicCredential.challenge, serializedPublicCredential.rpId),
    default: null
  });
  if (!getPasskeyModule) {
    return {
      publicKeyCredential: null,
      error: new import_utils.ClerkWebAuthnError("Platform is not supported", { code: "passkey_not_supported" })
    };
  }
  try {
    const response = await getPasskeyModule();
    return {
      publicKeyCredential: makeSerializedGetResponse(typeof response === "string" ? JSON.parse(response) : response),
      error: null
    };
  } catch (error) {
    return {
      publicKeyCredential: null,
      error: (0, import_utils.mapNativeErrorToClerkWebAuthnErrorCode)(error.code, error.message, "get")
    };
  }
}
const ANDROID_9 = 28;
const IOS_15 = 15;
function isSupported() {
  if (import_react_native.Platform.OS === "android") {
    return import_react_native.Platform.Version >= ANDROID_9;
  }
  if (import_react_native.Platform.OS === "ios") {
    return parseInt(import_react_native.Platform.Version, 10) > IOS_15;
  }
  return false;
}
const passkeys = {
  create,
  get,
  isSupported,
  isAutoFillSupported: () => {
    throw new Error("Not supported");
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  create,
  get,
  isSupported,
  passkeys
});
//# sourceMappingURL=index.js.map